<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Student Pickup Route Optimizer</title>
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-sA+e2b9u3w2gkXo3qk0h1QvQ8Kq1QvJb2Z+3x0xP4wE=" crossorigin="" />
  <style>
    :root{ --bg:#0f172a; --card:#0b1220; --accent:#4f46e5; --muted:#94a3b8; --glass: rgba(255,255,255,0.03);} 
    *{box-sizing:border-box;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,'Helvetica Neue',Arial}
    body{margin:0;background:linear-gradient(180deg,#071024 0%, #07182b 100%);color:#e6eef8;min-height:100vh;display:flex;align-items:flex-start;gap:18px;padding:28px}
    .container{max-width:1100px;margin:0 auto;width:100%;display:grid;grid-template-columns:420px 1fr;gap:20px}
    .card{background:var(--card);padding:18px;border-radius:12px;box-shadow:0 6px 18px rgba(2,6,23,0.6);border:1px solid rgba(255,255,255,0.03)}
    h1{font-size:20px;margin:0 0 8px}
    label{display:block;font-size:13px;color:var(--muted);margin-top:10px}
    input[type=text]{width:100%;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:var(--glass);color:inherit}
    .small{font-size:12px;color:var(--muted)}
    button{margin-top:12px;padding:10px 12px;border-radius:10px;border:0;background:linear-gradient(90deg,var(--accent),#06b6d4);color:white;font-weight:600;cursor:pointer}
    #map{height:78vh;border-radius:12px;border:1px solid rgba(255,255,255,0.03)}
    .row{display:flex;gap:8px}
    .muted{color:var(--muted)}
    .results{margin-top:12px;background:rgba(255,255,255,0.02);padding:10px;border-radius:8px}
    .waypoint{display:flex;align-items:center;justify-content:space-between;padding:6px 8px;border-radius:6px;border:1px dashed rgba(255,255,255,0.02);margin-top:8px}
    .links{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
    a.link{background:rgba(255,255,255,0.03);padding:8px;border-radius:8px;color:inherit;text-decoration:none;border:1px solid rgba(255,255,255,0.02)}
    footer{grid-column:1/-1;margin-top:8px;color:var(--muted);font-size:13px}
    @media (max-width:900px){body{padding:12px}.container{grid-template-columns:1fr}}
  </style>
</head>
<body>
  <div class="container">
    <div class="card">
      <h1>Student Pickup Route Optimizer</h1>
      <div class="small muted">Make a quick route: your current location → up to 6 pickups → final drop-off. The app geocodes addresses (OpenStreetMap) and picks the best order by total straight-line distance. Works offline for route order but can open directions in Google Maps.</div>

      <label>Start location (or click "Use my location")</label>
      <input type="text" id="start" placeholder="e.g. Lakeshore, Burlington or leave blank to use your GPS" />
      <div class="row" style="margin-top:8px;">
        <button id="useLocation">Use my location</button>
        <button id="addPickup">+ Add pickup</button>
        <button id="clearAll">Clear</button>
      </div>

      <div id="pickupsContainer">
        <!-- pickups dynamically added here -->
      </div>

      <label style="margin-top:10px">Final drop-off (school)</label>
      <input type="text" id="end" placeholder="e.g. John Doe Secondary School, address..." />

      <button id="optimize">Get best route</button>

      <div class="results" id="results" aria-live="polite"></div>

      <div class="links" id="links"></div>

      <div style="margin-top:10px;font-size:12px;color:var(--muted)">Notes: This file uses OpenStreetMap's Nominatim for address -> coordinates and Leaflet for map display. The route order is optimized using a brute-force check of permutations using straight-line distances (Haversine). For driving directions use the "Open in Google Maps" link (it will open with the optimized waypoint order).</div>
    </div>

    <div class="card">
      <div id="map"></div>
      <footer>Tip: For more accurate driving distance/time replace the geocoding + optimization with a Distance Matrix API (Google/Mapbox/ORS) — you can plug your API key in the script (comments included).</footer>
    </div>
  </div>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-o9N1j7kG8f2g46wY6bfxmQbXQfY5x7v1y0Z1b2w5q2U=" crossorigin=""></script>
  <script>
    // ------- Helper utilities -------
    function el(id){return document.getElementById(id)}
    function create(tag, cls){const t=document.createElement(tag); if(cls) t.className=cls; return t}

    // Haversine distance in meters
    function haversine(a,b){
      const R=6371000; // m
      const toRad = x => x*Math.PI/180;
      const dLat = toRad(b.lat-a.lat);
      const dLon = toRad(b.lon-a.lon);
      const lat1 = toRad(a.lat); const lat2 = toRad(b.lat);
      const hav = Math.sin(dLat/2)**2 + Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)**2;
      return 2*R*Math.asin(Math.sqrt(hav));
    }

    // Permutations helper
    function permutations(arr){
      const results=[];
      function permute(current, remaining){
        if(remaining.length===0){results.push(current.slice());return}
        for(let i=0;i<remaining.length;i++){const next=remaining[i]; const rest=remaining.slice(0,i).concat(remaining.slice(i+1)); current.push(next); permute(current,rest); current.pop();}
      }
      permute([],arr);
      return results;
    }

    // Geocode using Nominatim (OpenStreetMap). Returns {lat,lon,display_name}
    async function geocode(query){
      if(!query) throw new Error('Empty query');
      const url = 'https://nominatim.openstreetmap.org/search?format=json&q=' + encodeURIComponent(query) + '&limit=1&addressdetails=0';
      const res = await fetch(url, {headers: {'Accept': 'application/json'}});
      const data = await res.json();
      if(!data || data.length===0) throw new Error('No results for: ' + query);
      return {lat: parseFloat(data[0].lat), lon: parseFloat(data[0].lon), name: data[0].display_name};
    }

    // ------- UI wiring -------
    const pickupsContainer = el('pickupsContainer');
    const addPickupBtn = el('addPickup');
    const optimizeBtn = el('optimize');
    const resultsDiv = el('results');
    const linksDiv = el('links');
    const clearBtn = el('clearAll');
    const useLocationBtn = el('useLocation');

    let pickupCount = 0;
    function addPickup(value=''){
      pickupCount++;
      const id = 'pickup-' + pickupCount;
      const wrapper = create('div','waypoint');
      wrapper.id = id + '-wrap';
      const input = create('input'); input.type='text'; input.placeholder = 'Pickup address (e.g. 123 Main St, City)'; input.value = value; input.id = id;
      const del = create('button'); del.textContent = '✖'; del.title='Remove'; del.style.background='transparent'; del.style.border='0'; del.style.color='var(--muted)'; del.style.cursor='pointer';
      del.addEventListener('click',()=>{wrapper.remove();});
      wrapper.appendChild(input);
      wrapper.appendChild(del);
      pickupsContainer.appendChild(wrapper);
    }

    // Start with 3 pickups (as user described), but allow adding/removing
    addPickup(); addPickup(); addPickup();

    addPickupBtn.addEventListener('click',()=>addPickup());
    clearBtn.addEventListener('click',()=>{el('start').value=''; el('end').value=''; pickupsContainer.innerHTML=''; pickupCount=0; addPickup(); addPickup(); addPickup(); resultsDiv.innerHTML=''; linksDiv.innerHTML=''; mapLayer && mapLayer.remove(); markers.forEach(m=>m.remove()); markers=[]; polyline && polyline.remove();});

    useLocationBtn.addEventListener('click',async ()=>{
      if(!navigator.geolocation){alert('Geolocation not supported in this browser');return}
      useLocationBtn.textContent='Locating...';
      navigator.geolocation.getCurrentPosition(async pos=>{
        const lat = pos.coords.latitude, lon = pos.coords.longitude;
        el('start').value = lat + ',' + lon;
        useLocationBtn.textContent='Use my location';
        // center map
        map.setView([lat,lon],12);
        addMarker({lat,lon,name:'Your location'});
      }, err=>{alert('Could not get location: '+err.message); useLocationBtn.textContent='Use my location';});
    });

    // ------- Map setup -------
    const map = L.map('map', {zoomControl:true}).setView([43.32, -79.80], 11);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {maxZoom: 19, attribution: '&copy; OpenStreetMap contributors'}).addTo(map);

    let markers = [];
    let polyline = null;
    let mapLayer = null;
    function addMarker(pt, label){
      const m = L.marker([pt.lat, pt.lon]).addTo(map).bindPopup(label||pt.name||'');
      markers.push(m);
    }

    function clearMap(){ markers.forEach(m=>m.remove()); markers=[]; if(polyline) polyline.remove(); polyline=null; }

    // ------- Main optimization logic -------
    optimizeBtn.addEventListener('click', async ()=>{
      resultsDiv.innerHTML = 'Working...'; linksDiv.innerHTML=''; clearMap();
      try{
        // Collect inputs
        const startRaw = el('start').value.trim();
        const endRaw = el('end').value.trim();
        if(!endRaw) throw new Error('Please enter final drop-off (school) address.');
        const pickupInputs = Array.from(pickupsContainer.querySelectorAll('input')).map(i=>i.value.trim()).filter(v=>v.length>0);
        if(pickupInputs.length===0) throw new Error('Please enter at least one pickup address.');
        if(pickupInputs.length > 6) { if(!confirm('More than 6 pickups may be slow. Continue?')) return }

        // Geocode start (or parse lat,lon)
        let startPoint = null;
        if(startRaw === ''){
          // try geolocation
          resultsDiv.innerHTML = 'No start entered — trying browser geolocation...';
          const pos = await new Promise((res,rej)=> navigator.geolocation.getCurrentPosition(p=>res(p),e=>rej(e)));
          startPoint = {lat: pos.coords.latitude, lon: pos.coords.longitude, name: 'Your location'};
        } else if(/^\s*-?\d+(\.\d+)?,\s*-?\d+(\.\d+)?\s*$/.test(startRaw)){
          const [lat, lon] = startRaw.split(',').map(s=>parseFloat(s.trim())); startPoint = {lat,lon,name:'Start'};
        } else {
          resultsDiv.innerHTML = 'Geocoding start...'; startPoint = await geocode(startRaw);
        }

        // Geocode pickups
        resultsDiv.innerHTML = 'Geocoding ' + pickupInputs.length + ' pickups...';
        const pickupPoints = [];
        for(const p of pickupInputs){
          try{ const g = await geocode(p); pickupPoints.push(g); } catch(e){ throw new Error('Could not geocode pickup: ' + p + ' — ' + e.message); }
        }

        // Geocode end
        resultsDiv.innerHTML = 'Geocoding final destination...';
        const endPoint = /^\s*-?\d+(\.\d+)?,\s*-?\d+(\.\d+)?\s*$/.test(endRaw) ? {lat:parseFloat(endRaw.split(',')[0]), lon:parseFloat(endRaw.split(',')[1]), name:'End'} : await geocode(endRaw);

        // Compute best order: permutations of pickups
        resultsDiv.innerHTML = 'Calculating best order...';
        const perms = permutations(pickupPoints.map((p,i)=>i));
        let best = null; let bestOrder=null;
        for(const perm of perms){
          let total=0; let prev = startPoint;
          for(const idx of perm){ const pt = pickupPoints[idx]; total += haversine(prev, {lat:pt.lat, lon:pt.lon}); prev = {lat:pt.lat, lon:pt.lon}; }
          total += haversine(prev, {lat:endPoint.lat, lon:endPoint.lon});
          if(best===null || total < best){ best = total; bestOrder = perm.slice(); }
        }

        // Build ordered points
        const ordered = [startPoint].concat(bestOrder.map(i=>pickupPoints[i])).concat([endPoint]);

        // Show results and map
        resultsDiv.innerHTML = '<strong>Optimized order (approx)</strong><br><ol>' + ordered.slice(0,-1).map((pt,i)=>`<li>${i===0? 'Start: ':'Pickup: '}${pt.name || (pt.lat+','+pt.lon)}</li>`).join('') + '<li>Final drop-off: ' + endPoint.name + '</li></ol>' + '<div class="small muted">Total straight-line distance ≈ ' + (best/1000).toFixed(2) + ' km</div>';

        // Map markers and polyline
        ordered.forEach((pt,idx)=> addMarker({lat:pt.lat, lon:pt.lon}, (idx===0?'Start': idx===ordered.length-1 ? 'Drop-off' : 'Pickup') + (pt.name? '\n' + pt.name : '')));
        map.fitBounds(markers.map(m=>m.getLatLng()), {padding:[50,50]});
        polyline = L.polyline(ordered.map(p=>[p.lat,p.lon]), {weight:5,opacity:0.8}).addTo(map);

        // Google Maps directions link (waypoints in optimized order)
        const gmapsBase = 'https://www.google.com/maps/dir/?api=1';
        const origin = `${startPoint.lat},${startPoint.lon}`;
        const destination = `${endPoint.lat},${endPoint.lon}`;
        const waypoints = bestOrder.map(i=>`${pickupPoints[i].lat},${pickupPoints[i].lon}`).join('|');
        const gmaps = `${gmapsBase}&origin=${encodeURIComponent(origin)}&destination=${encodeURIComponent(destination)}&travelmode=driving${waypoints?('&waypoints=' + encodeURIComponent(waypoints)) : ''}`;

        // Also provide raw Google Maps link with addresses (human-readable)
        const gmapsNames = `${gmapsBase}&origin=${encodeURIComponent(startPoint.name || origin)}&destination=${encodeURIComponent(endPoint.name || destination)}&travelmode=driving${bestOrder.length?('&waypoints=' + encodeURIComponent(bestOrder.map(i=>pickupPoints[i].name).join('|'))):''}`;

        linksDiv.innerHTML = `<a class="link" href="${gmaps}" target="_blank" rel="noreferrer noopener">Open directions in Google Maps (coords)</a><a class="link" href="${gmapsNames}" target="_blank" rel="noreferrer noopener">Open directions in Google Maps (addresses)</a>`;

      } catch(err){ resultsDiv.innerHTML = '<span style="color:#ffb4b4">Error: ' + err.message + '</span>'; console.error(err); }
    });

    // Optional: if you want to plug an API-based distance matrix (driving times), you can replace the permutations scoring with fetching driving distances for each pair
    // (e.g., Google Distance Matrix, Mapbox Matrix, or OpenRouteService Matrix). For small numbers of pickups (<=8) brute-force permutations like above is fine.

  </script>
</body>
</html>

